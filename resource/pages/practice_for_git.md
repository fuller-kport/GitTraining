# つまらない前置きは終わった!!
著者第一号です，鶏頭と呼称してください．//著者が名乗りたい時はここで

# 何を作る?
このチュートリアルを作るに当たって，
Gitの演習には一体何がふさわしいのか色々考えるわけだ．

鶏頭:「なんか作るのにGitを使ってもらうのが良いかな?」

人間:「どうせ作るなら面白い方が良い」

人間:「使えるとモチベ上がるよね…」

鶏頭:「じゃぁゲームかな? テトリス? ぷよぷよ? マインスイーパ?」

鶏頭:「うーん… ここにはプログラミングしたことがない人も来るわけだから，
説明が面倒くさいやつは避けたいなぁ… それに機能を気軽に追加できるといい… かつみんなが知ってるやつ…」

# 人狼を作る!
というわけで人狼ゲームのホストを作るぜ．
ルールが分からない人は調べて来て．

ここで作る人狼は役職が村人と人狼しか無いけどGitHubの演習でもっと追加するから．

どうやって遊ぶか?
今回はゲームマスターを作る
自分の番が来たらPCの前に来て昼or夜の行動を選択するんだ
↑
後々通信出来るようにしたいね!

言語はc言語…色々難点はあるけど絶対に約に立つ言語の一つだし，習うからね．
~~難しく感じる人もいるからポインタ使えないし… 
マップもリストもポインタ必須だめ… ほんとはCじゃなくてLispとかPythonとかGoとかLispで書きたかった~~

## どんなものを作るか
何を作るかを最初にはっきりさせて置かないと，
俺が何やってるか分からないと思うが俺も何やってるか分からない状態になるから．

### 仕様
ユーザからの入力はどこから?
- 端末の標準入出力から

どんな役職がある?
- 村人
- 人狼
- 占い (後回し)
- 猟師 (後回し)

### ゲーム全体の流れ
0. 役職を割り振る
	1. 各役職の人数を入力してもらう
	1. 各プレイヤーの名前を入力してもらう+プレイヤーに役職を教える
1. 昼のターン
	1. 一定時間待つ
	1. 処刑したい人を選んでもらう
	1. 誰かが火あぶりにされる
	1. 終了判定 (人狼の数が村人の人数以上なら人狼の，村人しかいないなら村人の勝利)
1. 夜のターン
	1. 各プレイヤーの役職に応じて行動してもらう．
	1. 各プレイヤーの状態を決める
	1. 終了判定 (人狼の数が村人の人数以上なら人狼の，村人しかいないなら村人の勝利)
1. 各プレイヤーに夜のターンの結果を知らせる
1. 1に戻る

# 下準備
## 作業場所の作成
まず作業するディレクトリを作る，
名前は`werewolf`にしよう．
```
//ディレクトリを作るコマンド
mkdir [ディレクトリ名]
```
作ったらそこに移動しよう
```
//カレント(現在の)ディレクトリを変更
cd [変更先のディレクトリ]
```
## [テキストエディタ](https://www.jetbrains.com/)でファイルを作る

作るファイルは次の2つ

内容はコピペで
1. Makefile
```
TARGET = main.c

make_and_run:
	gcc -o werewolf.out $(TARGET)
	./werewolf.out
```
2. main.c
```
# include <stdio.h>

int main(void){
	printf("人狼");
	return 0;
}
```

次のコマンドをうって，`人狼`と出力されたらOKだ．
```
//Makefileに書かれた生成規則に従って，優先度の一番高いターゲットを作成するコマンド
//上のMakefileにはmain.cをコンパイルし実行せよと書いてある
make
```

## リポジトリの作成
`werewolf`ディレクトリをGitの管理下に置こう．
```
//カレント(現在の)ディレクトリをGitの管理下に置く(リポジトリの作成)
git init
```

# コーディング開始!
## 進め方
1. コードを書く(main.cを編集)
1. コンパイルを通す (make)
1. インデックスに変更を登録 (git add --all)
1. コミットする (git commit -m "[コミットメッセージ]")

基本はこれの繰り返しです．

## step1 何をするべきか書く
まずmain.cを編集する．
見通しよくプログラムを書くためにさっき書いたコメントを追加しよう．

[現在の状態](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step1)

追加できたらGitに現在の状態を記録しよう(コミット)!
```
//このリポジトリの管理下の全ての変更を記録することにする (インデックスに追加)
git add --all
//コメントをつけて記録する (インデックスに追加)
git commit -m "全体の構成をコメントとして追加"
```
## step2 プレイヤーをデータで表現する
コメントをコードに直す前に，プレイヤーをどうやって表現するかを決めたい．
プレイヤの表し方で必要なコードが変わるからだ．それに具体的に考えられるようにもなる．

プレイヤーを表すにはどんな情報が要るだろうか?

名前が要るね，役職も，そしてその生死…これくらい? 

この3つのセットだから構造体を使うのが自然だ．
Player構造体を作ってみよう! 

ここで問題になるのが役職をどう扱うかだ…今回は番号として扱う事にする．
数字のままだと分かりにくいのでenumタイプの型を作って，人にもわかりやすいようにした．
```
//名前の最大文字数
#define NAME_MAX_NUM 32

//役職を表すRole型を定義
//始めは単純な物を作りたいので，今はVILLAGER(村人)とWEREWOLF(人狼)だけだ．
typedef enum{
	VILLAGER, //実際は0
	WEREWOLF  //実際は1
}Role;

//プレイヤーを表すPlayer型を定義
typedef struct{
	Role role;               //役職番号
	char name[NAME_MAX_NUM]; //名前
	int is_live;             //生きているなら1, 死んでいるなら0
}Player;
```

main.cに追記しよう… [こんな感じに](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step2/main.c)

コンパイルは通るかな? 通ったらコミットしよう!
```
git add --all
git commit -m "プレイヤーを表す型を定義"
```

## step3 プレイヤー達を作る
プレイヤーをどう表すかが決まったので，実際にプレイヤー達を作る．
コメントの役職を割り振るってとこを雑に書くってこと．

とにかく早く全体を動かしたいので，後回しに出来るところを省く(夏休み前半の愚行)．
プレイヤーに役職や名前を割り振るところとか飛ばせますねぇ…

ついでにプレイヤーの状態を見られると便利なのでそのための関数を作って使う．

[こんな感じにね](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step3/main.c)

実行すると，上手く行っているのならプレイヤーの状態が見られるはずだ．

## ブランチを切る
コミットのやり方がわかった所で，step4を始める前にブランチ切ることにする．

今Gitの履歴はこうなっているはずだ(\*がコミットを表す)
```
*-*-*-
```

これを
```
*-*-*-
     \
      *
```
こうしたいんすね．

変更の連鎖の事をブランチと言う，
最初に作られる変更の連鎖をmasterブランチと呼び，
それ以外は自分で名前をつける．
```
*-*-*-      ←master ブランチ
     \
      *     ←[好きな名前] ブランチ
```

次のコマンドでブランチを作りそこに移動する．
ブランチ名はそうだなぁ`add_daytime`とかにしとくか．
```
git checkout -b [ブランチ名]
```

## step4 昼のターン
昼のターンでやるべきことはいっぱいある
- 話し合いが終わるまで待つ
- 独りずつ投票してもらう
- 投票結果を一人選ぶ(決戦投票なし)
- 処す

まず関数必要な関数をつくって最後に組み合わせよう．
### 待つ
タイマーをつけることも出来たが，今回は入力待ちをする関数を作る．
他の所でも使えるからね．~~僕はサボりたいのだ~~

```
//入力を全部読み捨てる
void clean_stdin(void){
	char c;
	for(;;){
		c = getchar();
		if (c == '\n' || c == EOF) break;
	}
}

//上の関数を待機用として用いる
void wait_key(void) {
	printf("<ENTER>\n");
	clean_stdin();
}
```

`getchar()`を書くだけでも入力待ちになる，この関数は\<ENTER\>Keyを押された時に一文字読み込むんだ．
では複数文字を入力された時はどうなるかというと一文字しか読み込まないので残りが
次に`getchar()`関数が呼ばれた時に自動で入力されてしまう…つまり入力待ちが起きないんだ!

ユーザは複数文字を入力してくるかもしれない…それに対応するためには入力を全部読み捨てる必要があった．

### 投票してもらう




###


