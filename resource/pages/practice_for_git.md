# つまらない前置きは終わった!!
# 何を作る?
このチュートリアルを作るに当たって，
Gitの演習には一体何がふさわしいのか色々考えるわけだ．

ぼく:「なんか作るのにGitを使ってもらうのが良いかな?」

人間:「どうせ作るなら面白い方が良い」

人間:「使えるとモチベ上がるよね…」

ぼく:「じゃぁゲームかな? テトリス? ぷよぷよ? マインスイーパ?」

ぼく:「うーん… ここにはプログラミングしたことがない人も来るわけだから，
説明が面倒くさいやつは避けたいなぁ… それに機能を気軽に追加できるといい… かつみんなが知ってるやつ…」

# 人狼を作る!
というわけで人狼ゲームのホストを作るぜ．
ルールが分からない人は調べて来て．

ここで作る人狼は役職が村人と人狼しか無いけどGitHubの演習でもっと追加するから．

どうやって遊ぶか?
今回はゲームマスターを作る
自分の番が来たらPCの前に来て昼or夜の行動を選択するんだ
↑
後々通信出来るようにしたいね!

言語はc言語…色々難点はあるけど絶対に約に立つ言語の一つだし，習うからね．
~~難しく感じる人もいるからポインタ使えないし… 
マップもリストもポインタ必須だめ… ほんとはCじゃなくてLispとかPythonとかGoとかLispで書きたかった~~

## どんなものを作るか
何を作るかを最初にはっきりさせて置かないと，
俺が何やってるか分からないと思うが俺も何やってるか分からない状態になるから．

### 仕様
ユーザからの入力はどこから?
- 端末の標準入出力から

どんな役職がある?
- 村人
- 人狼
- 占い (後回し)
- 猟師 (後回し)

### ゲーム全体の流れ
0. 役職を割り振る
	1. 各役職の人数を入力してもらう
	1. 各プレイヤーの名前を入力してもらう+プレイヤーに役職を教える
1. 昼のターン
	1. 一定時間待つ
	1. 処刑したい人を選んでもらう
	1. 誰かが火あぶりにされる
	1. 終了判定 (人狼の数が村人の人数以上なら人狼の，村人しかいないなら村人の勝利)
1. 夜のターン
	1. 各プレイヤーの役職に応じて行動してもらう．
	1. 各プレイヤーの状態を決める
	1. 終了判定 (人狼の数が村人の人数以上なら人狼の，村人しかいないなら村人の勝利)
1. 各プレイヤーに夜のターンの結果を知らせる
1. 1に戻る

# 下準備
## 作業場所の作成
まず作業するディレクトリを作る，
名前は`werewolf`にしよう．
```
//ディレクトリを作るコマンド
mkdir [ディレクトリ名]
```
作ったらそこに移動しよう
```
//カレント(現在の)ディレクトリを変更
cd [変更先のディレクトリ]
```
## [テキストエディタ](https://www.jetbrains.com/)でファイルを作る

作るファイルは次の2つ

内容はコピペで
1. Makefile
```
TARGET = main.c

make_and_run:
	gcc -o werewolf.out $(TARGET)
	./werewolf.out
```
2. main.c
```
# include <stdio.h>

int main(void){
	printf("人狼");
	return 0;
}
```

次のコマンドをうって，`人狼`と出力されたらOKだ．
```
//Makefileに書かれた生成規則に従って，優先度の一番高いターゲットを作成するコマンド
//上のMakefileにはmain.cをコンパイルし実行せよと書いてある
make
```

## リポジトリの作成
`werewolf`ディレクトリをGitの管理下に置こう．
```
//カレント(現在の)ディレクトリをGitの管理下に置く(リポジトリの作成)
git init
```

# コーディング開始!
## 進め方
1. コードを書く(main.cを編集)
1. コンパイルを通す (make)
1. インデックスに変更を登録 (git add --all)
1. コミットする (git commit -m "[コミットメッセージ]")

基本はこれの繰り返しです．

## step1 何をするべきか書く
まずmain.cを編集する．
見通しよくプログラムを書くためにさっき書いたコメントを追加しよう．

[現在の状態](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step1)

追加できたらGitに現在の状態を記録しよう(コミット)!
```
//このリポジトリの管理下の全ての変更を記録することにする (インデックスに追加)
git add --all
//コメントをつけて記録する (インデックスに追加)
git commit -m "全体の構成をコメントとして追加"
```
## step2 プレイヤーをデータで表現する
コメントをコードに直す前に，プレイヤーをどうやって表現するかを決めたい．
プレイヤの表し方で必要なコードが変わるからだ．それに具体的に考えられるようにもなる．

プレイヤーを表すにはどんな情報が要るだろうか?

名前が要るね，役職も，そしてその生死…これくらい? 

この3つのセットだから構造体を使うのが自然だ．
Player構造体を作ってみよう! 

ここで問題になるのが役職をどう扱うかだ…今回は番号として扱う事にする．
数字のままだと分かりにくいのでenumタイプの型を作って，人にもわかりやすいようにした．
```
//名前の最大文字数
#define NAME_MAX_NUM 32

//役職を表すRole型を定義
//始めは単純な物を作りたいので，今はVILLAGER(村人)とWEREWOLF(人狼)だけだ．
typedef enum{
	VILLAGER, //実際は0
	WEREWOLF  //実際は1
}Role;

//プレイヤーを表すPlayer型を定義
typedef struct{
	Role role;               //役職番号
	char name[NAME_MAX_NUM]; //名前
	int is_live;             //生きているなら1, 死んでいるなら0
}Player;
```

main.cに追記しよう… [こんな感じに](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step2/main.c)

コンパイルは通るかな? 通ったらコミットしよう!
```
git add --all
git commit -m "プレイヤーを表す型を定義"
```

## step3 プレイヤー達を作る
プレイヤーをどう表すかが決まったので，実際にプレイヤー達を作る．
コメントの役職を割り振るってとこを雑に書くってこと．

とにかく早く全体を動かしたいので，後回しに出来るところを省く(夏休み前半の愚行)．
プレイヤーに役職や名前を割り振るところとか飛ばせますねぇ…

ついでにプレイヤーの状態を見られると便利なのでそのための関数を作って使う．

[こんな感じにね](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step3/main.c)

実行すると，上手く行っているのならプレイヤーの状態が見られるはずだ．

## ブランチを切る
コミットのやり方がわかった所で，step4を始める前にブランチ切ることにする．

今Gitの履歴はこうなっているはずだ(\*がコミットを表す)
```
*-*-*-
```

これを
```
*-*-*-
     \
      *
```
こうしたいんすね．

変更の連鎖の事をブランチと言う，~~ほんとは1つのコミットの別名にすぎないんだけどね~~
最初に作られる変更の連鎖をmasterブランチと呼び，
それ以外は自分で名前をつける．
```
*-*-*-      ←master ブランチ
     \
      *     ←[好きな名前] ブランチ
```

次のコマンドでブランチを作りそこに移動する．
ブランチ名はそうだなぁ`add_daytime`とかにしとくか．
```
git checkout -b [ブランチ名]
```
ブランチの一覧は`git branch`コマンドで見れる，
カレントブランチには`*`印が付くのできちんとブランチが出来たか調べておこう．

## step4 昼のターン
昼のターンでやるべきことはいっぱいある
- 話し合いが終わるまで待つ
- 独りずつ投票してもらう
- 投票結果を一人選ぶ(決戦投票なし)
- 処す

最初に必要な関数をつくって最後に組み合わせる．

### 待つ
タイマーをつけることも出来たが，今回は入力待ちをする関数を作る．
他の所でも使えるからね．~~僕はサボりたいのだ~~

```
//入力を全部読み捨てる
void clean_stdin(void){
	char c;
	for(;;){
		c = getchar();
		if (c == '\n' || c == EOF) break;
	}
}

//上の関数を待機用として用いる
void wait_key(void) {
	printf("<ENTER>\n");
	clean_stdin();
}
```

`getchar()`を書くだけでも入力待ちになる，この関数は\<ENTER\>Keyを押された時に一文字読み込むんだ．
では複数文字を入力された時はどうなるかというと一文字しか読み込まないので残りが
次に`getchar()`関数が呼ばれた時に自動で入力されてしまう…つまり入力待ちが起きないんだ!

無粋なユーザが複数文字を入力してくるかもしれない…それに対応するためには入力を全部読み捨てる必要があった．

コミットしておこう!

### 投票してもらう
自分以外の生きているプレイヤーのNo.を読み込む関数を作る．
夜のターンにも使えそうだ．こいつは単純だから説明しなくてもいいかな．

```
//自分以外の生きているプレイヤーNo.を読み込む
int read_living_other_than_myself_player_num(Player players[], int players_num, int cur_player_num){
	int n;
	for (;;){
		printf("No.");
		scanf("%d", &n);
		if (n<0 || n>=players_num){
			printf("player No.%d は村にいません\n", n);
			continue;//次のループへ
		}
		if (n == cur_player_num){
			printf("自分自身は選択出来ません\n");
			continue;
		}
		if (!players[n].is_live){
			printf("player No.%d は既に死体です\n", n);
			continue;
		}
		wait_key();
		return n;//最後まで処理が進むのは値が正しいときだけ
	}
}
```

コミットしよう!

### 投票の犠牲者を選ぶ
各プレイヤーが何回ずつ投票されたかを配列に記録する事にする，
ここではその配列を受け取って投票の勝者を一人選ぶ関数を作ろう!．

```
//rand関数を使うためいる，#include ~はファイルの最初に書く
#include <stdlib.h>

//投票を集計して一人選ぶ
int ballot_winner(int ballot_box[], int size){
	int max = 0;//最大の得票数
	for(int i=0; i<size; i++) {
		if (max < ballot_box[i]) max = ballot_box[i]; 
	}
	int j = 0;//最大の投票数を得た人は何人いるか
	int arr[PLAYERS_MAX_NUM];//最大の投票数の人達(j人)
	for(int i=0; i<size; i++) {
		if (ballot_box[i] == max){
			arr[j] = i;
			j++;
		}
	}
	return arr[rand()%j];
}
```

コミットした?

### 画面をクリアする
前のユーザの行動が残っているとまずいね…
これでまっさらに出来る．
```
void clear(){
	puts("\033[2J");
};
```

### 関数を使う
ここまでで昼のターンを構成するパーツたちが揃った．
これらを使って昼のターンを作ろう!

全部合わせると[こんな風に](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step4/main.c)なる

`make`でコンパイル，実行してみて欲しい．
上手く処刑出来ている事を確認したらコミットして長かった昼のターン製作は終わりだ!やったぜ!
~~まだ終了判定は残ってるけど~~

コミットしてね，めんどくさがらずに．

## マージ(merge)しよう!
今コミットの流れは２つある，`master`と`add_daytime`だ．

step4ではmasterから分岐した流れである`add_daytime`を編集して昼のターンを実装したわけだ．
つまり`master`はまだstep3を終えた直後なので，
今回は`add_daytime`で記録した変更を`master`にも取り込みたい．

ブランチBの変更をブランチAに取り込むことをBをAにマージすると言う．
図で表すとこんな感じ，マージした時点で勝手にコミットされるんすね．
```
*-*-*-   (master)
     \
      *-*-*  (add_daytime)
```
↓add_daytimeをmasterにマージ
```
*-*-*-------*   (master)
     \     /
      *-*-*     (add_daytime)
```

まずはカレントブランチを`master`にしよう，`master`が`add_daytime`を取り込みたいからだ．

カレントブランチを変えるコマンドはこれ
```
git checkout [ブランチ名]
```

マージのコマンドはこれ
```
//カレントブランチに別のブランチを取り込む
git merge [取り込みたいブランチ]
```

## step5 夜のターン
夜のターンもブランチを切ってそこで作業しよう，ブランチ名は`add_midnight`とか?

夜のターンは個人作業の繰り返しだ，ただし役職毎に違う行動をさせなければならない．
[こんな風にね](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step5/main.c)
，ついでに昼から夜に移る際のメッセージも追加しておいた．

村人だけ即決だとゲームがつまらなくなるので，
村人には長岡高専電子制御科名物の数理演習をやってもらう!
`mathematical_exercises()`関数がそれなんだけど，特に気にしなくていい．

`make`で実行すると夜のターンで人狼が選んだプレイヤーがリストから消える様子が見えるはずだ．

`master`に`add_midnight`をマージしてここは終わり．

いやぁ〜長かった! 次で終わりだ!

## step6 最後(大嘘)の仕上げ
面倒かもしれないがまたブランチを切ろう(masterから分けてね)，名前は`finish`とか?

このままだとゲーム(夜が明けたら)終わっちゃうね!

昼のターンと夜のターンをループに入れて…

このままじゃゲーム終わんないね!

```
//どの陣営が勝ったか
typedef enum{
	NONE,
	VILLAGER_SIDE,
	WEREWOLF_SIDE
}WinSide;

//勝った陣営を返す
WinSide win_side(Player p[], int p_num){
	int werewolf_num = 0;
	int villager_num = 0;
	for(int i=0;i<p_num;i++){
		if(!p[i].is_live)continue;
		switch(p[i].role){
			case VILLAGER: villager_num++;break;
			case WEREWOLF: werewolf_num++;break;
		}
	}
	if(villager_num <= werewolf_num)return WEREWOLF_SIDE;
	if(werewolf_num <= 0)return VILLAGER_SIDE;
	return NONE;
}

```
これが勝者側を判定する関数だ!
この関数を[こんな感じに](https://github.com/fuller-kport/GitTraining/blob/master/resource/werewolf/step6/main.c)
使って，ゲームが終了するようになった．

`make`! やったぜ動いた! 思ったとおりに動いているなら完成だ!

コミットして`master`にマージして!

終 NHK…

あれ? そういえば前半に放置した名前入力とか役職選択とかやって無い…おかしいなぁ すっとぼけ

## 最終回前座 ~直前のコミット死す~
さっき`finish`ブランチを`master`にマージしちゃったけどまだ作業が残ってた…
`finish`ブランチを取り込んだのに完成していないのはなんか変だ，~~それに恥ずかしい~~
だから`finish`ブランチのマージを無かったことにしたい．

```
               匿名コミットのこいつを亡きものにしたい
                      ↓
*-*-*-------*---*-----* (master)
     \     / \ / \   /
      *-*-*   *   *-* (finish)
(add_daytime) (add_midnight)

```

無かった事にすると言っても色々ある

```
// 直前の変更を打ち消すコミットを作成
git revers [打ち消すコミット]
```
このコマンドでよく使うオプションはこれ，
- soft  コミットされた事だけ無かったことにする
- mixed softに加え，インデックスの内容も戻す
- hard  mixedに加え，インデックス，作業内容全部戻す

ちなみにGitではよく使うコミットをこんな記号で表す
- HEAD      :ワーキングツリーの最新のコミット
- ORIG_HEAD :HEADが移動するコマンドを叩いた際に、コマンド実行時のHEADの位置を記録

これらを使うとこんな感じに色々できる
```
//直前のコミットを取り消す(作業内容は残る)
git reset --soft HEAD
//直前のコミットを取り消す(作業内容も消える　実質 直前のさらにひとつ前のコミット直後に戻る)
git reset --hard HEAD
//直前のコミットの一つ前を取り消す(作業内容は残る)
git reset --soft ORIG_HEAD
//直前のコミットの一つ前を取り消す(作業内容も消える)
git reset --hard ORIG_HEAD
```

取り消すとは書いたが，指定したコミットに戻すという表現の方が正しい．
オプションはどこまで戻すか指定してる感じ．

今回は
```
git reset --hard HEAD
```
を使えば良さそうだ

ここまで戻ったので何事も無かったかのように出来た!
```
*-*-*-------*---*---- (master)
     \     / \ / \   
      *-*-*   *   *-* (finish)
(add_daytime) (add_midnight)

```

## step ほんとの最終回
`finish`ブランチに居るか確かめて最後の編集を始めよう!

### 名前を入力してもらう
### 夜の間に死んだ人を表示
### 乱数を本当にランダムにする
### 表示関数から役職表示を消す

コードのっけてマージさせるだけ


